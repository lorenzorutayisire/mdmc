#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

#define FACE_WEST  0
#define FACE_EAST  1
#define FACE_DOWN  2
#define FACE_UP    3
#define FACE_SOUTH 4
#define FACE_NORTH 5

#define VERTEX_SIZE (3 + 2 + 1)

layout(binding = 0, std430) buffer b_baked_block_pool
{
	float minecraft_block_buffer[];
};

uniform uint u_start;
uniform uint u_count;

uniform uvec3 u_size;

// ================================================================================================
// Minecraft block pool's voxel list
// ================================================================================================

#define COLLISION_DETECTED_VOXEL vec4(1)
#define ERROR_VOXEL              vec4(0)

layout(binding = 1) uniform atomic_uint u_alloc;

layout(binding = 2, rgb10_a2ui) uniform uimageBuffer u_voxel_position;
layout(binding = 3, rgba8) uniform imageBuffer u_voxel_color;

uniform uint u_store;

struct Obb
{
	vec3 C;
	vec3 A[3];
	float s[3];
};

vec3 get_vertex_position(uint element_id, uint face_id, uint vertex_id)
{
	uint vertex_location = u_start + element_id * (6 * 4) + face_id * 4 + vertex_id;
	uint location = vertex_location * VERTEX_SIZE;

	vec3 position;
	position.x = minecraft_block_buffer[location];
	position.y = minecraft_block_buffer[location + 1];
	position.z = minecraft_block_buffer[location + 2];

	return position;
}

// Reference:
// https://www.geometrictools.com/Documentation/DynamicCollisionDetection.pdf

bool check_obb(Obb obb)
{
	// Axes must be right-handed.
	if (dot(cross(obb.A[0], obb.A[1]), obb.A[2]) <= 0)
		return false;

	for (int i = 0; i <= 2; i++)
	{
		// Axes must be orthonormal (orthogonal + length 1).
		for (int j = 0; j <= 2; j++)
		{
			float d = dot(obb.A[i], obb.A[j]);
			if (i != j && (d <= -0.01 || d >= 0.01))
				return false;
		}

		float l = length(obb.A[i]);
		if (l <= -0.99 || l >= 1.01)
			return false;

		// Extents must be > 0.
		if (obb.s[i] <= 0)
			return false;
	}

	return true;
}

bool generate_voxel(out Obb obb, uvec3 position)
{
	vec3 side = 16.0 / vec3(u_size);
	
	vec3 A0 = vec3(side.x, 0, 0) / 2.0;
	vec3 A1 = vec3(0, side.y, 0) / 2.0;
	vec3 A2 = vec3(0, 0, side.z) / 2.0;
	
	vec3 _min = position * (vec3(16) / u_size);
	obb.C = _min + A0 + A1 + A2;

	obb.A[0] = normalize(A0);
	obb.A[1] = normalize(A1);
	obb.A[2] = normalize(A2);

	obb.s[0] = length(A0);
	obb.s[1] = length(A1);
	obb.s[2] = length(A2);

	return check_obb(obb);
}

bool generate_obb(out Obb obb, uint element_id)
{
	vec3 p0 = get_vertex_position(element_id, FACE_WEST, 1);

	vec3 A0 = (get_vertex_position(element_id, FACE_WEST, 0) - p0) / 2.0;
	vec3 A1 = (get_vertex_position(element_id, FACE_WEST, 2) - p0) / 2.0;
	vec3 A2 = (get_vertex_position(element_id, FACE_DOWN, 2) - p0) / 2.0;

	obb.C = p0 + A0 + A1 + A2;

	obb.A[0] = normalize(A0);
	obb.A[1] = normalize(A1);
	obb.A[2] = normalize(A2);

	obb.s[0] = length(A0);
	obb.s[1] = length(A1);
	obb.s[2] = length(A2);
	
	return check_obb(obb);
}

bool is_projection_separated(vec3 L, Obb obb1, Obb obb2)
{
	vec3 D = obb2.C - obb1.C;

	float R = abs(dot(L, D));
	float R0, R1;

	R0 = 0;
	R1 = 0;
	for (int i  = 0; i <= 2; i++)
	{
		R0 += obb1.s[i] * sign(dot(L, obb1.A[i])) * dot(L, obb1.A[i]); // abs(...)
		R1 += obb2.s[i] * sign(dot(L, obb2.A[i])) * dot(L, obb2.A[i]);
	}

	return R > R0 + R1;
}

bool is_colliding(Obb obb1, Obb obb2)
{
	for (int i = 0; i < 3; i++)
	{
		if (is_projection_separated(obb1.A[i], obb1, obb2))
			return false;

		if (is_projection_separated(obb2.A[i], obb1, obb2))
			return false;

		for (int j = 0; j < 3; j++)
		{
			if (is_projection_separated(cross(obb1.A[i], obb2.A[j]), obb1, obb2))
				return false;
		}
	}
	return true;
}

void push_voxel(uvec3 position, vec4 color)
{
	uint loc = atomicCounterIncrement(u_alloc);
	if (u_store == 1)
	{
		imageStore(u_voxel_position, int(loc), uvec4(position, 0));
		imageStore(u_voxel_color, int(loc), color);
	}
}

void main()
{
	uvec3 position = gl_GlobalInvocationID;
	if (position.x >= u_size.x || position.y >= u_size.y || position.z >= u_size.z)
		return;
	
	Obb voxel;
	if (!generate_voxel(voxel, position))
	{
		// TODO: remove?
		push_voxel(position, vec4(1, 0, 0, 1));
		return;
	}

	uint element_count = u_count / (6 * 4);
	for (uint element_id = 0; element_id < element_count; element_id++)
	{
		Obb obb;
		if (!generate_obb(obb, element_id))
		{
			push_voxel(position, vec4(0, 1, 0, 1));
			return;
		}

		if (is_colliding(voxel, obb))
		{
			push_voxel(position, vec4(position / vec3(u_size), 1));
			return;
		}
	}
}
