#version 430

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(binding = 2, rgb10_a2ui) uniform uimageBuffer u_voxel_position;

// ======================================================================
// Octree
// ======================================================================

layout(binding = 1, r32ui) uniform uimageBuffer u_octree;
uniform int u_octree_max_level;

uint get_index_at_level(uvec3 position, uint level)
{
	uint res = 0u;
	res |= ((position.x >> level) & 1u) << 2u;
	res |= ((position.y >> level) & 1u) << 1u;
	res |= ((position.z >> level) & 1u);
	return res;
}

uint tree_lookup(uvec3 position, int level)
{
	uint node_val = 0;
	for (; level > 0; level--)
	{
		node_val = imageLoad(u_octree, int(node_val)).r;
		node_val &= 0x7FFFFFFF;
		node_val += get_index_at_level(position, level);
	}
	return node_val;
}

uint pack_ui32(vec4 val)
{
	uint res = 0;
	res |= (uint(val.r * 255.0) & 0xff);
	res |= (uint(val.g * 255.0) & 0xff) << 8u;
	res |= (uint(val.b * 255.0) & 0xff) << 16u;
	res |= (uint(val.a * 127.0) & 0x7f) << 24u;
	return res;
}

// ======================================================================
// Main
// ======================================================================

layout(binding = 3, rgba8) uniform imageBuffer u_voxel_color;

void main()
{
	uint id = gl_GlobalInvocationID.x;
	if (id >= imageSize(u_voxel_position))
		return;

	uvec3 position = imageLoad(u_voxel_position, int(id)).rgb;
	vec4 voxel_col = imageLoad(u_voxel_color, int(id));

	uint idx;
	uint addr = 0;

	for (int level = u_octree_max_level; level >= 0; level--)
	{
		idx = get_index_at_level(position, level);
		if (level > 0)
			addr = imageLoad(u_octree, int(addr + idx)).r & 0x7fffffff;
	}

	imageStore(u_octree, int(addr + idx), uvec4(pack_ui32(voxel_col)));
}
