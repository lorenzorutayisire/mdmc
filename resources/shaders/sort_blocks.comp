#version 460

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

uniform uint swap_odd; // 0 = false, 1 = true

struct Voxel
{
	uvec3 position;
	vec4 color;
};

layout(std430, binding = 0) buffer volume_buffer
{
	Voxel volume[];
};

uniform uint volume_size;
uniform uint resolution;

layout(binding = 1) uniform atomic_uint swap_count; 

void main()
{
	uint idx = gl_GlobalInvocationID.x * 2 + swap_odd;
	if (idx + 1 >= volume_size) // last element
		return;

	// gets the block position of the two voxels
	uvec3 p1 = volume[idx].position / resolution;
	uvec3 p2 = volume[idx + 1].position / resolution;

	if (p1.x > p2.x || (p1.x == p2.x) && p1.y > p2.y || (p1.x == p2.x && p1.y == p2.y) && p1.z > p2.z)
	{
		Voxel tmp = volume[idx + 1];
		volume[idx + 1] = volume[idx];
		volume[idx] = tmp;

		atomicCounterIncrement(swap_count);
	}
}
