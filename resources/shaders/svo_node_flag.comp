#version 430

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// ======================================================================
// Octree
// ======================================================================

layout(binding = 1, r32ui) uniform uimageBuffer u_octree;
uniform uint u_octree_max_level;

// Gets the node at the given level where the position lies.
uint node_offset(uvec3 position, uint level)
{
	position &= uint(pow(2, u_octree_max_level) - 1);

	uint shift = u_octree_max_level - level;
	uint result = 0;
	result |= ((position.x >> shift) & 1) << 2;
	result |= ((position.y >> shift) & 1) << 1;
	result |= ((position.z >> shift) & 1);
	return result;
}

// ======================================================================
// Main
// ======================================================================

layout(binding = 2, rgb10_a2ui) uniform uimageBuffer u_voxel_position;
layout(binding = 3, rgba8) uniform imageBuffer u_voxel_color;

uniform uint u_level;

void main()
{
	uint id = gl_GlobalInvocationID.x;
	if (id >= imageSize(u_voxel_position))
		return;

	uvec4 position = imageLoad(u_voxel_position, int(id));

	uint address = 0;
	for (uint level = 0; level <= u_level; level++)
	{
		uint child_off = node_offset(position.xyz, level);

		if (level < u_level) // The current level hasn't been reached yet, jump through pointers.
			address = imageLoad(u_octree, int(address + child_off)).r & 0x7FFFFFFF;
		else
			imageStore(u_octree, int(address + child_off), uvec4(0x80000000));
	}
}
